"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/context/CartContext.tsx":
/*!*************************************!*\
  !*** ./src/context/CartContext.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CartProvider: function() { return /* binding */ CartProvider; },\n/* harmony export */   useCart: function() { return /* binding */ useCart; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ CartProvider,useCart auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\nconst CartContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst CartProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [items, setItems] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [isCartLoaded, setIsCartLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [cartError, setCartError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Load cart from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const loadCartFromStorage = ()=>{\n            if (false) {}\n            try {\n                const savedCart = localStorage.getItem(\"obsidian-cart\");\n                if (savedCart) {\n                    const parsedCart = JSON.parse(savedCart);\n                    // Validate cart data structure\n                    if (Array.isArray(parsedCart)) {\n                        // Add addedAt timestamp to items that don't have it (for backward compatibility)\n                        const validatedCart = parsedCart.map((item)=>({\n                                ...item,\n                                addedAt: item.addedAt || new Date().toISOString()\n                            }));\n                        setItems(validatedCart);\n                        console.log(\"Cart loaded from localStorage:\", validatedCart.length, \"items\");\n                    } else {\n                        console.warn(\"Invalid cart data structure, clearing cart\");\n                        localStorage.removeItem(\"obsidian-cart\");\n                    }\n                }\n                setCartError(null);\n            } catch (error) {\n                console.error(\"Error loading cart from localStorage:\", error);\n                setCartError(\"Failed to load cart data\");\n                // Clear corrupted data\n                localStorage.removeItem(\"obsidian-cart\");\n            } finally{\n                setIsCartLoaded(true);\n            }\n        };\n        loadCartFromStorage();\n    }, []);\n    // Save cart to localStorage whenever it changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isCartLoaded || \"object\" === \"undefined\") return;\n        try {\n            localStorage.setItem(\"obsidian-cart\", JSON.stringify(items));\n            console.log(\"Cart saved to localStorage:\", items.length, \"items\");\n            setCartError(null);\n        } catch (error) {\n            console.error(\"Error saving cart to localStorage:\", error);\n            setCartError(\"Failed to save cart data\");\n        }\n    }, [\n        items,\n        isCartLoaded\n    ]);\n    const addToCart = async (product, selectedSize, selectedColor, quantity)=>{\n        console.log(\"CartContext: addToCart called with:\", {\n            product,\n            selectedSize,\n            selectedColor,\n            quantity\n        });\n        const cartItemId = \"\".concat(product.id, \"-\").concat(selectedSize, \"-\").concat(selectedColor);\n        try {\n            // Check if this is a made-to-order product (no stock property)\n            const isMadeToOrder = !product.stock;\n            if (isMadeToOrder) {\n                alert('Made-to-order products cannot be added to cart. Please use the \"Order Now\" button to place your order.');\n                return;\n            }\n            if (!isMadeToOrder) {\n                var _product_stock_selectedSize, _product_stock;\n                // Simple stock check - no reservation, just check if available\n                const availableStock = ((_product_stock = product.stock) === null || _product_stock === void 0 ? void 0 : (_product_stock_selectedSize = _product_stock[selectedSize]) === null || _product_stock_selectedSize === void 0 ? void 0 : _product_stock_selectedSize[selectedColor]) || 0;\n                // Check if the specific size/color combination is available\n                if (availableStock === 0) {\n                    alert(\"❌ Size \".concat(selectedSize, \" in \").concat(selectedColor, \" is OUT OF STOCK!\"));\n                    return;\n                }\n                // Check if requested quantity exceeds available stock\n                if (quantity > availableStock) {\n                    alert(\"❌ Not enough stock available in \".concat(selectedSize, \" \").concat(selectedColor, \"! Only \").concat(availableStock, \" available.\"));\n                    return;\n                }\n                console.log(\"✅ Stock check passed - adding to cart\");\n            } else {\n                console.log(\"✅ Made-to-order product - no stock check needed\");\n            }\n            // If inventory reservation successful (or skipped for made-to-order), add to cart\n            setItems((prevItems)=>{\n                const existingItem = prevItems.find((item)=>item.id === cartItemId);\n                if (existingItem) {\n                    // Update existing item quantity\n                    const newQuantity = existingItem.quantity + quantity;\n                    return prevItems.map((item)=>item.id === cartItemId ? {\n                            ...item,\n                            quantity: newQuantity\n                        } : item);\n                } else {\n                    // Add new item\n                    const newItem = {\n                        id: cartItemId,\n                        productId: product.id,\n                        name: product.name,\n                        price: product.price,\n                        image: product.image,\n                        selectedSize,\n                        selectedColor,\n                        quantity,\n                        addedAt: new Date().toISOString()\n                    };\n                    return [\n                        ...prevItems,\n                        newItem\n                    ];\n                }\n            });\n            console.log(\"✅ Item added to cart and inventory reserved\");\n        } catch (error) {\n            console.error(\"❌ Error adding to cart:\", error);\n            alert(\"❌ Failed to add item to cart. Please try again.\");\n        }\n    };\n    const removeFromCart = async (id)=>{\n        const itemToRemove = items.find((item)=>item.id === id);\n        if (!itemToRemove) return;\n        try {\n            // Restore inventory when removing from cart\n            const restoreResponse = await fetch(\"/api/inventory/restore\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    productId: itemToRemove.productId,\n                    size: itemToRemove.selectedSize,\n                    color: itemToRemove.selectedColor,\n                    quantity: itemToRemove.quantity\n                })\n            });\n            if (!restoreResponse.ok) {\n                console.error(\"❌ Failed to restore inventory, but removing from cart anyway\");\n            }\n            setItems((prevItems)=>prevItems.filter((item)=>item.id !== id));\n            console.log(\"✅ Item removed from cart and inventory restored\");\n        } catch (error) {\n            console.error(\"❌ Error removing from cart:\", error);\n            // Still remove from cart even if inventory restore fails\n            setItems((prevItems)=>prevItems.filter((item)=>item.id !== id));\n        }\n    };\n    const updateQuantity = async (id, quantity)=>{\n        if (quantity <= 0) {\n            await removeFromCart(id);\n            return;\n        }\n        const item = items.find((item)=>item.id === id);\n        if (!item) return;\n        const currentQuantity = item.quantity;\n        const quantityDifference = quantity - currentQuantity;\n        if (quantityDifference === 0) return; // No change needed\n        try {\n            // Check if this is a made-to-order product (no stock property)\n            const isMadeToOrder = !item.stock;\n            if (!isMadeToOrder) {\n                if (quantityDifference > 0) {\n                    // Increasing quantity - reserve more inventory\n                    const reserveResponse = await fetch(\"/api/inventory/reserve\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            productId: item.productId,\n                            size: item.selectedSize,\n                            color: item.selectedColor,\n                            quantity: quantityDifference\n                        })\n                    });\n                    if (!reserveResponse.ok) {\n                        const errorData = await reserveResponse.json();\n                        alert(\"❌ Cannot increase quantity: \".concat(errorData.error || \"Unknown error\"));\n                        return;\n                    }\n                } else {\n                    // Decreasing quantity - restore some inventory\n                    const restoreResponse = await fetch(\"/api/inventory/restore\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            productId: item.productId,\n                            size: item.selectedSize,\n                            color: item.selectedColor,\n                            quantity: Math.abs(quantityDifference)\n                        })\n                    });\n                    if (!restoreResponse.ok) {\n                        console.error(\"❌ Failed to restore inventory, but updating quantity anyway\");\n                    }\n                }\n            } else {\n                console.log(\"✅ Skipping inventory operations for made-to-order product\");\n            }\n            // Update the cart\n            setItems((prevItems)=>prevItems.map((item)=>item.id === id ? {\n                        ...item,\n                        quantity\n                    } : item));\n            console.log(\"✅ Quantity updated and inventory synced\");\n        } catch (error) {\n            console.error(\"❌ Error updating quantity:\", error);\n            alert(\"❌ Failed to update quantity. Please try again.\");\n        }\n    };\n    const clearCart = async ()=>{\n        // Restore inventory for all items before clearing\n        for (const item of items){\n            try {\n                await fetch(\"/api/inventory/restore\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        productId: item.productId,\n                        size: item.selectedSize,\n                        color: item.selectedColor,\n                        quantity: item.quantity\n                    })\n                });\n            } catch (error) {\n                console.error(\"❌ Failed to restore inventory for item:\", item.id, error);\n            }\n        }\n        setItems([]);\n        // Also clear from localStorage\n        if (true) {\n            localStorage.removeItem(\"obsidian-cart\");\n        }\n        console.log(\"✅ Cart cleared and all inventory restored\");\n    };\n    // Function to clear cart data (useful for debugging or reset)\n    const clearCartData = ()=>{\n        setItems([]);\n        if (true) {\n            localStorage.removeItem(\"obsidian-cart\");\n        }\n        setCartError(null);\n    };\n    const getTotalItems = ()=>{\n        return items.reduce((total, item)=>total + item.quantity, 0);\n    };\n    const getTotalPrice = ()=>{\n        return items.reduce((total, item)=>total + item.price * item.quantity, 0);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CartContext.Provider, {\n        value: {\n            items,\n            addToCart,\n            removeFromCart,\n            updateQuantity,\n            clearCart,\n            getTotalItems,\n            getTotalPrice,\n            isCartLoaded,\n            cartError\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\HP\\\\Desktop\\\\Obsidian wear\\\\projectt\\\\src\\\\context\\\\CartContext.tsx\",\n        lineNumber: 307,\n        columnNumber: 5\n    }, undefined);\n};\n_s(CartProvider, \"A2jDBIPBxhVU6AU9PP6VbnYE1rQ=\");\n_c = CartProvider;\nconst useCart = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(CartContext);\n    if (context === undefined) {\n        throw new Error(\"useCart must be used within a CartProvider\");\n    }\n    return context;\n};\n_s1(useCart, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"CartProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0L0NhcnRDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRXlGO0FBMEJ6RixNQUFNSyw0QkFBY0osb0RBQWFBLENBQThCSztBQUV4RCxNQUFNQyxlQUFlO1FBQUMsRUFBRUMsUUFBUSxFQUEyQjs7SUFDaEUsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdQLCtDQUFRQSxDQUFhLEVBQUU7SUFDakQsTUFBTSxDQUFDUSxjQUFjQyxnQkFBZ0IsR0FBR1QsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDVSxXQUFXQyxhQUFhLEdBQUdYLCtDQUFRQSxDQUFnQjtJQUUxRCx1Q0FBdUM7SUFDdkNDLGdEQUFTQSxDQUFDO1FBQ1IsTUFBTVcsc0JBQXNCO1lBQzFCLElBQUksS0FBa0IsRUFBYSxFQUFPO1lBRTFDLElBQUk7Z0JBQ0YsTUFBTUMsWUFBWUMsYUFBYUMsT0FBTyxDQUFDO2dCQUN2QyxJQUFJRixXQUFXO29CQUNiLE1BQU1HLGFBQWFDLEtBQUtDLEtBQUssQ0FBQ0w7b0JBRTlCLCtCQUErQjtvQkFDL0IsSUFBSU0sTUFBTUMsT0FBTyxDQUFDSixhQUFhO3dCQUM3QixpRkFBaUY7d0JBQ2pGLE1BQU1LLGdCQUFnQkwsV0FBV00sR0FBRyxDQUFDLENBQUNDLE9BQWU7Z0NBQ25ELEdBQUdBLElBQUk7Z0NBQ1BDLFNBQVNELEtBQUtDLE9BQU8sSUFBSSxJQUFJQyxPQUFPQyxXQUFXOzRCQUNqRDt3QkFFQW5CLFNBQVNjO3dCQUNUTSxRQUFRQyxHQUFHLENBQUMsa0NBQWtDUCxjQUFjUSxNQUFNLEVBQUU7b0JBQ3RFLE9BQU87d0JBQ0xGLFFBQVFHLElBQUksQ0FBQzt3QkFDYmhCLGFBQWFpQixVQUFVLENBQUM7b0JBQzFCO2dCQUNGO2dCQUNBcEIsYUFBYTtZQUNmLEVBQUUsT0FBT3FCLE9BQU87Z0JBQ2RMLFFBQVFLLEtBQUssQ0FBQyx5Q0FBeUNBO2dCQUN2RHJCLGFBQWE7Z0JBQ2IsdUJB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Z0I7UUFDcEIsT0FBT3pFLE1BQU11RSxNQUFNLENBQUMsQ0FBQ0MsT0FBT3ZELE9BQVN1RCxRQUFTdkQsS0FBSzhCLEtBQUssR0FBRzlCLEtBQUtnQixRQUFRLEVBQUc7SUFDN0U7SUFFQSxxQkFDRSw4REFBQ3JDLFlBQVk4RSxRQUFRO1FBQUNDLE9BQU87WUFDM0IzRTtZQUNBNkI7WUFDQW9CO1lBQ0FXO1lBQ0FRO1lBQ0FFO1lBQ0FHO1lBQ0F2RTtZQUNBRTtRQUNGO2tCQUNHTDs7Ozs7O0FBR1AsRUFBRTtHQWxTV0Q7S0FBQUE7QUFvU04sTUFBTThFLFVBQVU7O0lBQ3JCLE1BQU1DLFVBQVVwRixpREFBVUEsQ0FBQ0c7SUFDM0IsSUFBSWlGLFlBQVloRixXQUFXO1FBQ3pCLE1BQU0sSUFBSWlGLE1BQU07SUFDbEI7SUFDQSxPQUFPRDtBQUNULEVBQUU7SUFOV0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRleHQvQ2FydENvbnRleHQudHN4P2JlZDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENhcnRJdGVtIHtcbiAgaWQ6IHN0cmluZztcbiAgcHJvZHVjdElkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgcHJpY2U6IG51bWJlcjtcbiAgaW1hZ2U6IHN0cmluZztcbiAgc2VsZWN0ZWRTaXplOiBzdHJpbmc7XG4gIHNlbGVjdGVkQ29sb3I6IHN0cmluZztcbiAgcXVhbnRpdHk6IG51bWJlcjtcbiAgYWRkZWRBdDogc3RyaW5nOyAvLyBUaW1lc3RhbXAgd2hlbiBpdGVtIHdhcyBhZGRlZFxufVxuXG5pbnRlcmZhY2UgQ2FydENvbnRleHRUeXBlIHtcbiAgaXRlbXM6IENhcnRJdGVtW107XG4gIGFkZFRvQ2FydDogKHByb2R1Y3Q6IGFueSwgc2VsZWN0ZWRTaXplOiBzdHJpbmcsIHNlbGVjdGVkQ29sb3I6IHN0cmluZywgcXVhbnRpdHk6IG51bWJlcikgPT4gUHJvbWlzZTx2b2lkPjtcbiAgcmVtb3ZlRnJvbUNhcnQ6IChpZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICB1cGRhdGVRdWFudGl0eTogKGlkOiBzdHJpbmcsIHF1YW50aXR5OiBudW1iZXIpID0+IFByb21pc2U8dm9pZD47XG4gIGNsZWFyQ2FydDogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZ2V0VG90YWxJdGVtczogKCkgPT4gbnVtYmVyO1xuICBnZXRUb3RhbFByaWNlOiAoKSA9PiBudW1iZXI7XG4gIGlzQ2FydExvYWRlZDogYm9vbGVhbjtcbiAgY2FydEVycm9yOiBzdHJpbmcgfCBudWxsO1xufVxuXG5jb25zdCBDYXJ0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8Q2FydENvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG5leHBvcnQgY29uc3QgQ2FydFByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3ROb2RlIH0pID0+IHtcbiAgY29uc3QgW2l0ZW1zLCBzZXRJdGVtc10gPSB1c2VTdGF0ZTxDYXJ0SXRlbVtdPihbXSk7XG4gIGNvbnN0IFtpc0NhcnRMb2FkZWQsIHNldElzQ2FydExvYWRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjYXJ0RXJyb3IsIHNldENhcnRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICAvLyBMb2FkIGNhcnQgZnJvbSBsb2NhbFN0b3JhZ2Ugb24gbW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBsb2FkQ2FydEZyb21TdG9yYWdlID0gKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNhdmVkQ2FydCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdvYnNpZGlhbi1jYXJ0Jyk7XG4gICAgICAgIGlmIChzYXZlZENhcnQpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRDYXJ0ID0gSlNPTi5wYXJzZShzYXZlZENhcnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFZhbGlkYXRlIGNhcnQgZGF0YSBzdHJ1Y3R1cmVcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRDYXJ0KSkge1xuICAgICAgICAgICAgLy8gQWRkIGFkZGVkQXQgdGltZXN0YW1wIHRvIGl0ZW1zIHRoYXQgZG9uJ3QgaGF2ZSBpdCAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0ZWRDYXJ0ID0gcGFyc2VkQ2FydC5tYXAoKGl0ZW06IGFueSkgPT4gKHtcbiAgICAgICAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgICAgICAgYWRkZWRBdDogaXRlbS5hZGRlZEF0IHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzZXRJdGVtcyh2YWxpZGF0ZWRDYXJ0KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDYXJ0IGxvYWRlZCBmcm9tIGxvY2FsU3RvcmFnZTonLCB2YWxpZGF0ZWRDYXJ0Lmxlbmd0aCwgJ2l0ZW1zJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBjYXJ0IGRhdGEgc3RydWN0dXJlLCBjbGVhcmluZyBjYXJ0Jyk7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnb2JzaWRpYW4tY2FydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRDYXJ0RXJyb3IobnVsbCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGNhcnQgZnJvbSBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgICAgICBzZXRDYXJ0RXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNhcnQgZGF0YScpO1xuICAgICAgICAvLyBDbGVhciBjb3JydXB0ZWQgZGF0YVxuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnb2JzaWRpYW4tY2FydCcpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNDYXJ0TG9hZGVkKHRydWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsb2FkQ2FydEZyb21TdG9yYWdlKCk7XG4gIH0sIFtdKTtcblxuICAvLyBTYXZlIGNhcnQgdG8gbG9jYWxTdG9yYWdlIHdoZW5ldmVyIGl0IGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzQ2FydExvYWRlZCB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnb2JzaWRpYW4tY2FydCcsIEpTT04uc3RyaW5naWZ5KGl0ZW1zKSk7XG4gICAgICBjb25zb2xlLmxvZygnQ2FydCBzYXZlZCB0byBsb2NhbFN0b3JhZ2U6JywgaXRlbXMubGVuZ3RoLCAnaXRlbXMnKTtcbiAgICAgIHNldENhcnRFcnJvcihudWxsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIGNhcnQgdG8gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICAgIHNldENhcnRFcnJvcignRmFpbGVkIHRvIHNhdmUgY2FydCBkYXRhJyk7XG4gICAgfVxuICB9LCBbaXRlbXMsIGlzQ2FydExvYWRlZF0pO1xuXG4gIGNvbnN0IGFkZFRvQ2FydCA9IGFzeW5jIChwcm9kdWN0OiBhbnksIHNlbGVjdGVkU2l6ZTogc3RyaW5nLCBzZWxlY3RlZENvbG9yOiBzdHJpbmcsIHF1YW50aXR5OiBudW1iZXIpID0+IHtcbiAgICBjb25zb2xlLmxvZygnQ2FydENvbnRleHQ6IGFkZFRvQ2FydCBjYWxsZWQgd2l0aDonLCB7IHByb2R1Y3QsIHNlbGVjdGVkU2l6ZSwgc2VsZWN0ZWRDb2xvciwgcXVhbnRpdHkgfSk7XG4gICAgY29uc3QgY2FydEl0ZW1JZCA9IGAke3Byb2R1Y3QuaWR9LSR7c2VsZWN0ZWRTaXplfS0ke3NlbGVjdGVkQ29sb3J9YDtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIG1hZGUtdG8tb3JkZXIgcHJvZHVjdCAobm8gc3RvY2sgcHJvcGVydHkpXG4gICAgICBjb25zdCBpc01hZGVUb09yZGVyID0gIXByb2R1Y3Quc3RvY2s7XG4gICAgICBcbiAgICAgIGlmIChpc01hZGVUb09yZGVyKSB7XG4gICAgICAgIGFsZXJ0KCdNYWRlLXRvLW9yZGVyIHByb2R1Y3RzIGNhbm5vdCBiZSBhZGRlZCB0byBjYXJ0LiBQbGVhc2UgdXNlIHRoZSBcIk9yZGVyIE5vd1wiIGJ1dHRvbiB0byBwbGFjZSB5b3VyIG9yZGVyLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghaXNNYWRlVG9PcmRlcikge1xuICAgICAgICAvLyBTaW1wbGUgc3RvY2sgY2hlY2sgLSBubyByZXNlcnZhdGlvbiwganVzdCBjaGVjayBpZiBhdmFpbGFibGVcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlU3RvY2sgPSBwcm9kdWN0LnN0b2NrPy5bc2VsZWN0ZWRTaXplXT8uW3NlbGVjdGVkQ29sb3JdIHx8IDA7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc3BlY2lmaWMgc2l6ZS9jb2xvciBjb21iaW5hdGlvbiBpcyBhdmFpbGFibGVcbiAgICAgICAgaWYgKGF2YWlsYWJsZVN0b2NrID09PSAwKSB7XG4gICAgICAgICAgYWxlcnQoYOKdjCBTaXplICR7c2VsZWN0ZWRTaXplfSBpbiAke3NlbGVjdGVkQ29sb3J9IGlzIE9VVCBPRiBTVE9DSyFgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHJlcXVlc3RlZCBxdWFudGl0eSBleGNlZWRzIGF2YWlsYWJsZSBzdG9ja1xuICAgICAgICBpZiAocXVhbnRpdHkgPiBhdmFpbGFibGVTdG9jaykge1xuICAgICAgICAgIGFsZXJ0KGDinYwgTm90IGVub3VnaCBzdG9jayBhdmFpbGFibGUgaW4gJHtzZWxlY3RlZFNpemV9ICR7c2VsZWN0ZWRDb2xvcn0hIE9ubHkgJHthdmFpbGFibGVTdG9ja30gYXZhaWxhYmxlLmApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgU3RvY2sgY2hlY2sgcGFzc2VkIC0gYWRkaW5nIHRvIGNhcnQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgTWFkZS10by1vcmRlciBwcm9kdWN0IC0gbm8gc3RvY2sgY2hlY2sgbmVlZGVkJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGludmVudG9yeSByZXNlcnZhdGlvbiBzdWNjZXNzZnVsIChvciBza2lwcGVkIGZvciBtYWRlLXRvLW9yZGVyKSwgYWRkIHRvIGNhcnRcbiAgICAgIHNldEl0ZW1zKHByZXZJdGVtcyA9PiB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHByZXZJdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5pZCA9PT0gY2FydEl0ZW1JZCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZXhpc3RpbmdJdGVtKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGl0ZW0gcXVhbnRpdHlcbiAgICAgICAgICBjb25zdCBuZXdRdWFudGl0eSA9IGV4aXN0aW5nSXRlbS5xdWFudGl0eSArIHF1YW50aXR5O1xuICAgICAgICAgIHJldHVybiBwcmV2SXRlbXMubWFwKGl0ZW0gPT5cbiAgICAgICAgICAgIGl0ZW0uaWQgPT09IGNhcnRJdGVtSWRcbiAgICAgICAgICAgICAgPyB7IC4uLml0ZW0sIHF1YW50aXR5OiBuZXdRdWFudGl0eSB9XG4gICAgICAgICAgICAgIDogaXRlbVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWRkIG5ldyBpdGVtXG4gICAgICAgICAgY29uc3QgbmV3SXRlbTogQ2FydEl0ZW0gPSB7XG4gICAgICAgICAgICBpZDogY2FydEl0ZW1JZCxcbiAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdC5pZCxcbiAgICAgICAgICAgIG5hbWU6IHByb2R1Y3QubmFtZSxcbiAgICAgICAgICAgIHByaWNlOiBwcm9kdWN0LnByaWNlLFxuICAgICAgICAgICAgaW1hZ2U6IHByb2R1Y3QuaW1hZ2UsXG4gICAgICAgICAgICBzZWxlY3RlZFNpemUsXG4gICAgICAgICAgICBzZWxlY3RlZENvbG9yLFxuICAgICAgICAgICAgcXVhbnRpdHksXG4gICAgICAgICAgICBhZGRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBbLi4ucHJldkl0ZW1zLCBuZXdJdGVtXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgSXRlbSBhZGRlZCB0byBjYXJ0IGFuZCBpbnZlbnRvcnkgcmVzZXJ2ZWQnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGFkZGluZyB0byBjYXJ0OicsIGVycm9yKTtcbiAgICAgIGFsZXJ0KCfinYwgRmFpbGVkIHRvIGFkZCBpdGVtIHRvIGNhcnQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlbW92ZUZyb21DYXJ0ID0gYXN5bmMgKGlkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBpdGVtVG9SZW1vdmUgPSBpdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5pZCA9PT0gaWQpO1xuICAgIGlmICghaXRlbVRvUmVtb3ZlKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgLy8gUmVzdG9yZSBpbnZlbnRvcnkgd2hlbiByZW1vdmluZyBmcm9tIGNhcnRcbiAgICAgIGNvbnN0IHJlc3RvcmVSZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2ludmVudG9yeS9yZXN0b3JlJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBwcm9kdWN0SWQ6IGl0ZW1Ub1JlbW92ZS5wcm9kdWN0SWQsXG4gICAgICAgICAgc2l6ZTogaXRlbVRvUmVtb3ZlLnNlbGVjdGVkU2l6ZSxcbiAgICAgICAgICBjb2xvcjogaXRlbVRvUmVtb3ZlLnNlbGVjdGVkQ29sb3IsXG4gICAgICAgICAgcXVhbnRpdHk6IGl0ZW1Ub1JlbW92ZS5xdWFudGl0eVxuICAgICAgICB9KVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzdG9yZVJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gcmVzdG9yZSBpbnZlbnRvcnksIGJ1dCByZW1vdmluZyBmcm9tIGNhcnQgYW55d2F5Jyk7XG4gICAgICB9XG5cbiAgICAgIHNldEl0ZW1zKHByZXZJdGVtcyA9PiBwcmV2SXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pZCAhPT0gaWQpKTtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgSXRlbSByZW1vdmVkIGZyb20gY2FydCBhbmQgaW52ZW50b3J5IHJlc3RvcmVkJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciByZW1vdmluZyBmcm9tIGNhcnQ6JywgZXJyb3IpO1xuICAgICAgLy8gU3RpbGwgcmVtb3ZlIGZyb20gY2FydCBldmVuIGlmIGludmVudG9yeSByZXN0b3JlIGZhaWxzXG4gICAgICBzZXRJdGVtcyhwcmV2SXRlbXMgPT4gcHJldkl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uaWQgIT09IGlkKSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHVwZGF0ZVF1YW50aXR5ID0gYXN5bmMgKGlkOiBzdHJpbmcsIHF1YW50aXR5OiBudW1iZXIpID0+IHtcbiAgICBpZiAocXVhbnRpdHkgPD0gMCkge1xuICAgICAgYXdhaXQgcmVtb3ZlRnJvbUNhcnQoaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBpdGVtID0gaXRlbXMuZmluZChpdGVtID0+IGl0ZW0uaWQgPT09IGlkKTtcbiAgICBpZiAoIWl0ZW0pIHJldHVybjtcblxuICAgIGNvbnN0IGN1cnJlbnRRdWFudGl0eSA9IGl0ZW0ucXVhbnRpdHk7XG4gICAgY29uc3QgcXVhbnRpdHlEaWZmZXJlbmNlID0gcXVhbnRpdHkgLSBjdXJyZW50UXVhbnRpdHk7XG5cbiAgICBpZiAocXVhbnRpdHlEaWZmZXJlbmNlID09PSAwKSByZXR1cm47IC8vIE5vIGNoYW5nZSBuZWVkZWRcblxuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgbWFkZS10by1vcmRlciBwcm9kdWN0IChubyBzdG9jayBwcm9wZXJ0eSlcbiAgICAgIGNvbnN0IGlzTWFkZVRvT3JkZXIgPSAhaXRlbS5zdG9jaztcbiAgICAgIFxuICAgICAgaWYgKCFpc01hZGVUb09yZGVyKSB7XG4gICAgICAgIGlmIChxdWFudGl0eURpZmZlcmVuY2UgPiAwKSB7XG4gICAgICAgICAgLy8gSW5jcmVhc2luZyBxdWFudGl0eSAtIHJlc2VydmUgbW9yZSBpbnZlbnRvcnlcbiAgICAgICAgICBjb25zdCByZXNlcnZlUmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9pbnZlbnRvcnkvcmVzZXJ2ZScsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIHByb2R1Y3RJZDogaXRlbS5wcm9kdWN0SWQsXG4gICAgICAgICAgICAgIHNpemU6IGl0ZW0uc2VsZWN0ZWRTaXplLFxuICAgICAgICAgICAgICBjb2xvcjogaXRlbS5zZWxlY3RlZENvbG9yLFxuICAgICAgICAgICAgICBxdWFudGl0eTogcXVhbnRpdHlEaWZmZXJlbmNlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFyZXNlcnZlUmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc2VydmVSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBhbGVydChg4p2MIENhbm5vdCBpbmNyZWFzZSBxdWFudGl0eTogJHtlcnJvckRhdGEuZXJyb3IgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZWNyZWFzaW5nIHF1YW50aXR5IC0gcmVzdG9yZSBzb21lIGludmVudG9yeVxuICAgICAgICAgIGNvbnN0IHJlc3RvcmVSZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2ludmVudG9yeS9yZXN0b3JlJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgcHJvZHVjdElkOiBpdGVtLnByb2R1Y3RJZCxcbiAgICAgICAgICAgICAgc2l6ZTogaXRlbS5zZWxlY3RlZFNpemUsXG4gICAgICAgICAgICAgIGNvbG9yOiBpdGVtLnNlbGVjdGVkQ29sb3IsXG4gICAgICAgICAgICAgIHF1YW50aXR5OiBNYXRoLmFicyhxdWFudGl0eURpZmZlcmVuY2UpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFyZXN0b3JlUmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gcmVzdG9yZSBpbnZlbnRvcnksIGJ1dCB1cGRhdGluZyBxdWFudGl0eSBhbnl3YXknKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgU2tpcHBpbmcgaW52ZW50b3J5IG9wZXJhdGlvbnMgZm9yIG1hZGUtdG8tb3JkZXIgcHJvZHVjdCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGhlIGNhcnRcbiAgICAgIHNldEl0ZW1zKHByZXZJdGVtcyA9PiBcbiAgICAgICAgcHJldkl0ZW1zLm1hcChpdGVtID0+IFxuICAgICAgICAgIGl0ZW0uaWQgPT09IGlkID8geyAuLi5pdGVtLCBxdWFudGl0eSB9IDogaXRlbVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFF1YW50aXR5IHVwZGF0ZWQgYW5kIGludmVudG9yeSBzeW5jZWQnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHVwZGF0aW5nIHF1YW50aXR5OicsIGVycm9yKTtcbiAgICAgIGFsZXJ0KCfinYwgRmFpbGVkIHRvIHVwZGF0ZSBxdWFudGl0eS4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY2xlYXJDYXJ0ID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vIFJlc3RvcmUgaW52ZW50b3J5IGZvciBhbGwgaXRlbXMgYmVmb3JlIGNsZWFyaW5nXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZXRjaCgnL2FwaS9pbnZlbnRvcnkvcmVzdG9yZScsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBwcm9kdWN0SWQ6IGl0ZW0ucHJvZHVjdElkLFxuICAgICAgICAgICAgc2l6ZTogaXRlbS5zZWxlY3RlZFNpemUsXG4gICAgICAgICAgICBjb2xvcjogaXRlbS5zZWxlY3RlZENvbG9yLFxuICAgICAgICAgICAgcXVhbnRpdHk6IGl0ZW0ucXVhbnRpdHlcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gcmVzdG9yZSBpbnZlbnRvcnkgZm9yIGl0ZW06JywgaXRlbS5pZCwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldEl0ZW1zKFtdKTtcbiAgICAvLyBBbHNvIGNsZWFyIGZyb20gbG9jYWxTdG9yYWdlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnb2JzaWRpYW4tY2FydCcpO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygn4pyFIENhcnQgY2xlYXJlZCBhbmQgYWxsIGludmVudG9yeSByZXN0b3JlZCcpO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGNsZWFyIGNhcnQgZGF0YSAodXNlZnVsIGZvciBkZWJ1Z2dpbmcgb3IgcmVzZXQpXG4gIGNvbnN0IGNsZWFyQ2FydERhdGEgPSAoKSA9PiB7XG4gICAgc2V0SXRlbXMoW10pO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ29ic2lkaWFuLWNhcnQnKTtcbiAgICB9XG4gICAgc2V0Q2FydEVycm9yKG51bGwpO1xuICB9O1xuXG4gIGNvbnN0IGdldFRvdGFsSXRlbXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGl0ZW1zLnJlZHVjZSgodG90YWwsIGl0ZW0pID0+IHRvdGFsICsgaXRlbS5xdWFudGl0eSwgMCk7XG4gIH07XG5cbiAgY29uc3QgZ2V0VG90YWxQcmljZSA9ICgpID0+IHtcbiAgICByZXR1cm4gaXRlbXMucmVkdWNlKCh0b3RhbCwgaXRlbSkgPT4gdG90YWwgKyAoaXRlbS5wcmljZSAqIGl0ZW0ucXVhbnRpdHkpLCAwKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxDYXJ0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17e1xuICAgICAgaXRlbXMsXG4gICAgICBhZGRUb0NhcnQsXG4gICAgICByZW1vdmVGcm9tQ2FydCxcbiAgICAgIHVwZGF0ZVF1YW50aXR5LFxuICAgICAgY2xlYXJDYXJ0LFxuICAgICAgZ2V0VG90YWxJdGVtcyxcbiAgICAgIGdldFRvdGFsUHJpY2UsXG4gICAgICBpc0NhcnRMb2FkZWQsXG4gICAgICBjYXJ0RXJyb3JcbiAgICB9fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0NhcnRDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHVzZUNhcnQgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KENhcnRDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlQ2FydCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgQ2FydFByb3ZpZGVyJyk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsIkNhcnRDb250ZXh0IiwidW5kZWZpbmVkIiwiQ2FydFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJpdGVtcyIsInNldEl0ZW1zIiwiaXNDYXJ0TG9hZGVkIiwic2V0SXNDYXJ0TG9hZGVkIiwiY2FydEVycm9yIiwic2V0Q2FydEVycm9yIiwibG9hZENhcnRGcm9tU3RvcmFnZSIsInNhdmVkQ2FydCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZWRDYXJ0IiwiSlNPTiIsInBhcnNlIiwiQXJyYXkiLCJpc0FycmF5IiwidmFsaWRhdGVkQ2FydCIsIm1hcCIsIml0ZW0iLCJhZGRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsIndhcm4iLCJyZW1vdmVJdGVtIiwiZXJyb3IiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiYWRkVG9DYXJ0IiwicHJvZHVjdCIsInNlbGVjdGVkU2l6ZSIsInNlbGVjdGVkQ29sb3IiLCJxdWFudGl0eSIsImNhcnRJdGVtSWQiLCJpZCIsImlzTWFkZVRvT3JkZXIiLCJzdG9jayIsImFsZXJ0IiwiYXZhaWxhYmxlU3RvY2siLCJwcmV2SXRlbXMiLCJleGlzdGluZ0l0ZW0iLCJmaW5kIiwibmV3UXVhbnRpdHkiLCJuZXdJdGVtIiwicHJvZHVjdElkIiwibmFtZSIsInByaWNlIiwiaW1hZ2UiLCJyZW1vdmVGcm9tQ2FydCIsIml0ZW1Ub1JlbW92ZSIsInJlc3RvcmVSZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJzaXplIiwiY29sb3IiLCJvayIsImZpbHRlciIsInVwZGF0ZVF1YW50aXR5IiwiY3VycmVudFF1YW50aXR5IiwicXVhbnRpdHlEaWZmZXJlbmNlIiwicmVzZXJ2ZVJlc3BvbnNlIiwiZXJyb3JEYXRhIiwianNvbiIsIk1hdGgiLCJhYnMiLCJjbGVhckNhcnQiLCJjbGVhckNhcnREYXRhIiwiZ2V0VG90YWxJdGVtcyIsInJlZHVjZSIsInRvdGFsIiwiZ2V0VG90YWxQcmljZSIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VDYXJ0IiwiY29udGV4dCIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/context/CartContext.tsx\n"));

/***/ })

});